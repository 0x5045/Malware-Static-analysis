import hashlib
import subprocess
import re
import datetime
import pefile


toolpath = ""

def listimports(mype2):#returns the list of functions
	
	import_list = []
	if mype2.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']].VirtualAddress != 0:
		mype2.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']])
		for entry in mype2.DIRECTORY_ENTRY_IMPORT:
			for imptab in entry.imports:
				x = imptab.name
				#x = hex(imptab.address), imptab.name
				import_list.append(x.decode('utf-8'))
	return import_list

def Entropy(data):
	if data > 6.50 and data < 6.99 :
		return str(data)+' --> Almost Packed'
	elif data > 7.00:
		return str(data)+' --> Packed'
	return str(data)
	
	
def Retrive_data_from_PE(input_file):
	#print 'SHA-256' + str(get_hash_sha256())
	#10B for 32bit & 20B for 64bit
	final_out = ""
	md5 = hashlib.md5(open(input_file,'rb').read()).hexdigest()
	sha256 = hashlib.sha256(open(input_file,'rb').read()).hexdigest()
	try:
		pe = pefile.PE(input_file, fast_load = True)
	except Exception as e:
		final_out = "not a PE File"
		print('unable to open file \n'+str(e))
		return final_out
	
	final_out += "MD5: %s\nSHA256: %s\n" % (str(md5),str(sha256))

	if int("010b", 16) == int(hex(pe.OPTIONAL_HEADER.Magic), 16):
		Magic = "  File Type = 32_bit_file" 
	elif int("020b", 16) == int(hex(pe.OPTIONAL_HEADER.Magic), 16):
		Magic = "  File Type = 64_bit_file"
	else:
		Magic = "unknown"
	
	Exe = hex(int(hex(pe.FILE_HEADER.Characteristics), 16) & int("2", 16)) # anding with 2 to identify EXE file
	Dll = hex(int(hex(pe.FILE_HEADER.Characteristics), 16) & int("2000", 16)) # anding with 2000 to identify DLL file
	if(int(Dll,16)) == int("0x2000", 16): #hex 2000 (int 8192) for Dll and 2 for exe
		Magic += "   DLL"
	elif (int(Exe, 16) == 2):
		Magic += "   EXE"
	else:
		Magic += "TypeUnknown"
	
	FileChar = hex(pe.FILE_HEADER.Characteristics)
	NumSection = "  NumSction = " + str( hex(pe.FILE_HEADER.NumberOfSections))
	MajorLinkerVersion = "  Majlinker = " + str( hex(pe.OPTIONAL_HEADER.MajorLinkerVersion))
	MinorLinkerVersion = "  Minlinker = " + str( hex(pe.OPTIONAL_HEADER.MinorLinkerVersion))
	MajorOs = "  MajorOS = " + str( hex(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion))
	MinorOs = "  MinorOS = " + str( hex(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion))
	FileAlignment = "  FileAlign = " + str( hex(pe.OPTIONAL_HEADER.FileAlignment))
	SectionAlignment = "  SectAlign = " + str( hex(pe.OPTIONAL_HEADER.SectionAlignment))
	SizeOfHeaders = "  SizeOfHdr = " + str( hex(pe.OPTIONAL_HEADER.SizeOfHeaders))
	Imagebase = "  ImageBase = " + str( hex(pe.OPTIONAL_HEADER.ImageBase))
	Subsystem = "  Subsystem = " + str( hex(pe.OPTIONAL_HEADER.Subsystem))
	
	isDotNet = pe.OPTIONAL_HEADER.DATA_DIRECTORY[14]
	
		
	timedate =  int(hex(pe.FILE_HEADER.TimeDateStamp), 16)
	
	
	
	if (pe.OPTIONAL_HEADER.DATA_DIRECTORY[9].VirtualAddress) > 0 :
		Tls_dir = '  Tls_size  = ' + str(hex(pe.OPTIONAL_HEADER.DATA_DIRECTORY[9].Size))
	else:
		Tls_dir = '  Tls_size  = No_Tls_dir'
	
	FileChar = '  File_Char = '+ str(hex(pe.FILE_HEADER.Characteristics))
	Dllchar = "  DllCharct = " + str( hex(pe.OPTIONAL_HEADER.DllCharacteristics))
	Entrypoint = "  Entrypnt  = " + str( hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint))
	
	
	final_out += '***********************************************************************************************' + '\n'
	Retrived_Chars = Magic + '\n'+  NumSection +'\n'  + MajorLinkerVersion + '\n' + MinorLinkerVersion +'\n'  + Imagebase + '\n'  + SectionAlignment + '\n'  + FileAlignment + '\n'  + SizeOfHeaders + '\n'  + Subsystem + '\n'  + Tls_dir + '\n'  + FileChar + '\n'  + Dllchar 
	Retrived_Chars +='\n'+ Entrypoint
	final_out += Retrived_Chars + '\n'
	
	final_out += "  CreatedOn = "+datetime.datetime.utcfromtimestamp(float(timedate)).strftime('%Y-%m-%d %H:%M:%S')+ '\n'
	if isDotNet.VirtualAddress == 0 and isDotNet.Size == 0:
		final_out += '\n  \t\tFile is Not a .NET executable'+ '\n'
	else:
		final_out += '\n  \t\tFile is .NET executable'+ '\n'
	
	final_out += '\n***********************************************************************************************\n'
	
	final_out += '\nSectName \tVirAddr\t\tVirSiz\t\tEntropy\n'+ '\n'
	for section in pe.sections:
		final_out += str(section.Name).replace('\\x00','')+'\t\t' + str(hex(section.VirtualAddress))+ '\t\t'+ str(hex(section.Misc_VirtualSize)) + '\t\t'+ str(Entropy(section.get_entropy()))+ '\n'
	
		
	
	final_out += '\n***********************************************************************************************\n'		
	final_out += "\n\tImported Functions\n"
	final_out += '\n'		
	functions = listimports(pe)
	
	for index in range(0,len(functions),1):
		#final_out += index
		final_out += '\t' + str(functions[index]) + '\n'# + '\t' + functions[index + 1] + '\t' + functions[index + 2]
	
	final_out += '***********************************************************************************************'
	
	return final_out
	
def Retrive_and_Classify_strings(input_file):
	try:
		cmd_output = subprocess.check_output('Supp_tools\\strings.exe -n 6 \"'+ input_file + '\" -nobanner ', shell=True)
	except subprocess.CalledProcessError as e:
		raise RuntimeError("command '{}' return with error (code {}): {}".format(e.cmd, e.returncode, e.output))
		#cmd_output = e.output
		exit()
	cmd_output = cmd_output.decode('utf-8')
	Strings_Output = cmd_output.split('\n')
	
	url_list = []
	pdb_list = []
	exe_names = []
	dll_names = []
	clsid = []
	registry_key = []
	star_dot_star = []
	Malicious_array1 = []
	Malicious_array2 = []
	counter = 0
	
	
	regex=r"\b((?:https?://)?(?:(?:www\.)?(?:[\da-z\.-]+)\.(?:[a-z]{2,6})|(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:(?:[0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(?:(?::[0-9a-fA-F]{1,4}){1,6})|:(?:(?::[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(?::[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(?:ffff(?::0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|(?:[0-9a-fA-F]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])))(?::[0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])?(?:/[\w\.-]*)*/?)\b"
		
	#*.*
	#with open("Supp_tools\string_output_file.txt", "r") as file:
	for line in Strings_Output:
	#for -*-*-*
		if 2 < line.count('-'):
			if len(line) < 30:
				clsid.append(line)
	#*.*
		if '.' in line:
			star_dot_star.append(str(line))
	#registry
		if 'CurrentVersion' in line:
			registry_key.append(str(line))
	#Exe names
		if '.exe' in line:
			exe_names.append(str(line))
	#url
			
				
		if ('http' in line) or ('.com' in line) or ('www' in line) or ('.net' in line) or ('https' in line):
			if ('symantec' not in line) and ('digicert' not in line) and ('symcb' not in line) and ('microsoft' not in line) and ('comodo' not in line) and ('adobe.com' not in line) and ('wosign' not in line) and ('globalsign' not in line) and ('wwww' not in line) and ('thawte' not in line) and ('jrsoftware' not in line) and ('godaddy' not in line) and ('nsis' not in line) and ('verisign' not in line) and ('usertrust' not in line) and ('starfieldtech' not in line) and ('symcd' not in line) and ('symauth' not in line) and ('jihosoft' not in line) and ('comodo' not in line) and ('certum' not in line) and ('subca' not in line) and ('sysinternals' not in line):
				matches = re.findall(regex, line)	
				for i in matches:
					url_list.append(str(i)+'\n')
	#pdb_path
		if '.pdb' in line:
			pdb_list.append(str(line))
	#DLL
		if '.dll' in line:
			dll_names.append(str(line))
	
	
	final_out = []
	if len(registry_key) != 0:	
		final_out.append('\n registry_keys:\n')
		for item in registry_key:
			final_out.append(str('\t'+item))
	
	if len(clsid) != 0:	
		final_out.append("\n\n\nCLSIDs or string with more '-':\n")
		for item in clsid:
			final_out.append(str('\t'+item))
			
	if len(url_list) != 0:
		final_out.append('\n\n\nUrls:\n')
		for item in url_list:
			final_out.append(str('\t'+item))
	if len(pdb_list) != 0:
		final_out.append('\n\n\nPDB_Paths:\n')
		for item in pdb_list:
			final_out.append(str('\t'+item))
		
	if len(exe_names) != 0:	
		final_out.append('\n\n\nEXE_Names:\n')
		for item in exe_names:
			final_out.append(str('\t'+item))
			
	if len(dll_names) != 0:
		final_out.append('\n\n\nDLL_Names:\n')
		for item in dll_names:
			final_out.append(str('\t'+item))
	
	#printing *.*
	if len(star_dot_star) != 0:
		final_out.append('\n\n\nAll Strings with dot:\n')
		for item in star_dot_star:
			final_out.append(str('\t'+item))
	
	
	
	#compare with malstringdb
	Malarray = [] 
	with open("Supp_tools\\malstringdb.txt", "r") as f:
		for line in f:
			line = line.strip()
			Malarray.append(line)
		
	Strings_Output_check1 = []
	Strings_Output_check2 = []
	for item in Strings_Output:
		Strings_Output_check1.append(item.replace('\r',''))
		Strings_Output_check2.append(item.replace('\r',''))
		
	Malicious_array1 = frozenset(Strings_Output_check1).intersection(Malarray)
	
	#compare with malstringdb
	Malarray = [] 
	with open("Supp_tools\\malstringdb_2_strings.txt", "r") as f:
		for line in f:
			line = line.strip()
			Malarray.append(line)
	
			
	Malicious_array2 = frozenset(Strings_Output_check2).intersection(Malarray)
		
	
	if len(Malicious_array1) != 0:
		final_out.append(str('\n\nMalicious_String 1:'))
		for item in Malicious_array1:
			final_out.append(str('\n\t'+item))
	
	
	if len(Malicious_array2) != 0:
		final_out.append(str('\n\nMalicious_String 2:'))
		for item in Malicious_array2:
			final_out.append(str('\n\t'+item))
	
	return final_out